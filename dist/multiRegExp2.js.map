{"version":3,"sources":["../src/multiRegExp2.js"],"names":["addGroupToRegexString","str","start","end","groupsAdded","substring","fillGroups","regex","regexString","modifier","source","flags","toString","lastIndexOf","substr","tester","modifiedRegex","lastGroupStartPosition","lastGroupEndPosition","lastNonGroupStartPosition","lastNonGroupEndPosition","groupCount","matchArr","nonGroupPositions","groupPositions","groupNumber","currentLengthIndexes","groupIndexMapper","previousGroupsForGroup","exec","index","length","push","lastGroupPosition","Math","max","slice","pop","toPush","filter","regexp","RegExp","MultiRegExp2","baseRegExp","string","includeFullMatch","matches","prototype","call","firstIndex","indexMapper","Object","assign","previousGroups","keys","map","group","mapped","r","match","reduce","sum","i"],"mappings":"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","file":"multiRegExp2.js","sourcesContent":["/**\n * Created by velten on 11.02.17.\n */\n\n/**\n * Adds brackets before and after a part of string\n * @param str string the hole regex string\n * @param start int marks the position where ( should be inserted\n * @param end int marks the position where ) should be inserted\n * @param groupsAdded int defines the offset to the original string because of inserted brackets\n * @return {string}\n */\nfunction addGroupToRegexString(str, start, end, groupsAdded) {\n  start += groupsAdded * 2;\n  end += groupsAdded * 2;\n  return str.substring(0, start) + '(' + str.substring(start, end + 1) + ')' + str.substring(end + 1);\n}\n\n/**\n * converts the given regex to a regex where all not captured string are going to be captured\n * it along sides generates a mapper which maps the original group index to the shifted group offset and\n * generates a list of groups indexes (including new generated capturing groups)\n * which have been closed before a given group index (unshifted)\n *\n * Example:\n * regexp: /a(?: )bc(def(ghi)xyz)/g => /(a(?: )bc)((def)(ghi)(xyz))/g\n * groupIndexMapper: {'1': 2, '2', 4}\n * previousGroupsForGroup: {'1': [1], '2': [1, 3]}\n *\n * @param regex RegExp\n * @return {{regexp: RegExp, groupIndexMapper: {}, previousGroupsForGroup: {}}}\n */\nfunction fillGroups(regex) {\n  let regexString;\n  let modifier;\n  if (regex.source && regex.flags) {\n    regexString = regex.source;\n    modifier = regex.flags;\n  }\n  else {\n    regexString = regex.toString();\n    modifier = regexString.substring(regexString.lastIndexOf(regexString[0]) + 1); // sometimes order matters ;)\n    regexString = regexString.substr(1, regex.toString().lastIndexOf(regexString[0]) - 1);\n  }\n  // regexp is greedy so it should match (? before ( right?\n  // brackets may be not quoted by \\\n  // closing bracket may look like: ), )+, )+?, ){1,}?, ){1,1111}?\n\tconst tester = /(\\\\\\()|(\\\\\\))|(\\(\\?)|(\\()|(\\)(?:\\{\\d+,?\\d*}|[*+?])?\\??)/g;\n\n  let modifiedRegex = regexString;\n\n  let lastGroupStartPosition = -1;\n  let lastGroupEndPosition = -1;\n  let lastNonGroupStartPosition = -1;\n  let lastNonGroupEndPosition = -1;\n  let groupsAdded = 0;\n  let groupCount = 0;\n  let matchArr;\n  const nonGroupPositions = [];\n  const groupPositions = [];\n  const groupNumber = [];\n  let currentLengthIndexes = [];\n  const groupIndexMapper = {};\n  const previousGroupsForGroup = {};\n  while ((matchArr = tester.exec(regexString)) !== null) {\n    if(matchArr[1] || matchArr[2]) { // ignore escaped brackets \\(, \\)\n\n    }\n    if (matchArr[3]) { // non capturing group (?\n      let index = matchArr.index + matchArr[0].length - 1;\n\n      lastNonGroupStartPosition = index;\n      nonGroupPositions.push(index);\n    }\n    else if (matchArr[4]) { // capturing group (\n      let index = matchArr.index + matchArr[0].length - 1;\n\n      let lastGroupPosition = Math.max(lastGroupStartPosition, lastGroupEndPosition);\n\n      // if a (? is found add ) before it\n      if(lastNonGroupStartPosition > lastGroupPosition) {\n        // check if between ) of capturing group lies a non capturing group\n        if(lastGroupPosition < lastNonGroupEndPosition) {\n          // add groups for x1 and x2 on (?:()x1)x2(?:...\n          if((lastNonGroupEndPosition - 1) - (lastGroupPosition + 1) > 0) {\n            modifiedRegex = addGroupToRegexString(modifiedRegex, lastGroupPosition + 1, lastNonGroupEndPosition - 1, groupsAdded);\n            groupsAdded++;\n            lastGroupEndPosition = lastNonGroupEndPosition - 1; // imaginary position as it is not in regex but modifiedRegex\n            currentLengthIndexes.push(groupCount + groupsAdded);\n          }\n\n          if((lastNonGroupStartPosition - 1) - (lastNonGroupEndPosition + 1) > 0) {\n            modifiedRegex = addGroupToRegexString(modifiedRegex, lastNonGroupEndPosition + 1, lastNonGroupStartPosition - 2, groupsAdded);\n            groupsAdded++;\n            lastGroupEndPosition = lastNonGroupStartPosition - 1; // imaginary position as it is not in regex but modifiedRegex\n            currentLengthIndexes.push(groupCount + groupsAdded);\n          }\n        }\n        else {\n          modifiedRegex = addGroupToRegexString(modifiedRegex, lastGroupPosition + 1, lastNonGroupStartPosition - 2, groupsAdded);\n          groupsAdded++;\n          lastGroupEndPosition = lastNonGroupStartPosition - 1; // imaginary position as it is not in regex but modifiedRegex\n          currentLengthIndexes.push(groupCount + groupsAdded);\n        }\n\n        // if necessary also add group between (? and opening bracket\n        if(index > lastNonGroupStartPosition + 2) {\n          modifiedRegex = addGroupToRegexString(modifiedRegex, lastNonGroupStartPosition + 2, index - 1, groupsAdded);\n          groupsAdded++;\n          lastGroupEndPosition = index - 1; // imaginary position as it is not in regex but modifiedRegex\n          currentLengthIndexes.push(groupCount + groupsAdded);\n        }\n      }\n      else if (lastGroupPosition < index - 1) {\n        modifiedRegex = addGroupToRegexString(modifiedRegex, lastGroupPosition + 1, index - 1, groupsAdded);\n        groupsAdded++;\n        lastGroupEndPosition = index - 1; // imaginary position as it is not in regex but modifiedRegex\n        currentLengthIndexes.push(groupCount + groupsAdded);\n      }\n\n      groupCount++;\n      lastGroupStartPosition = index;\n      groupPositions.push(index);\n      groupNumber.push(groupCount + groupsAdded);\n      groupIndexMapper[groupCount] = groupCount + groupsAdded;\n      previousGroupsForGroup[groupCount] = currentLengthIndexes.slice();\n    }\n    else if (matchArr[5]) { // closing bracket ), )+, )+?, ){1,}?, ){1,1111}?\n      let index = matchArr.index + matchArr[0].length - 1;\n\n      if ((groupPositions.length && !nonGroupPositions.length) ||\n        groupPositions[groupPositions.length - 1] > nonGroupPositions[nonGroupPositions.length - 1]\n      ) {\n        if (lastGroupStartPosition < lastGroupEndPosition && lastGroupEndPosition < index - 1) {\n          modifiedRegex = addGroupToRegexString(modifiedRegex, lastGroupEndPosition + 1, index - 1, groupsAdded);\n          groupsAdded++;\n          //lastGroupEndPosition = index - 1; will be set anyway\n          currentLengthIndexes.push(groupCount + groupsAdded);\n        }\n\n        groupPositions.pop();\n        lastGroupEndPosition = index;\n\n        let toPush = groupNumber.pop();\n        currentLengthIndexes.push(toPush);\n        currentLengthIndexes = currentLengthIndexes.filter(index => index <= toPush);\n      }\n      else if (nonGroupPositions.length) {\n        nonGroupPositions.pop();\n        lastNonGroupEndPosition = index;\n      }\n    }\n  }\n\n  return {regexp: new RegExp(modifiedRegex, modifier), groupIndexMapper, previousGroupsForGroup};\n}\n\nexport default class MultiRegExp2 {\n  constructor(baseRegExp) {\n    const {regexp, groupIndexMapper, previousGroupsForGroup} = fillGroups(baseRegExp);\n    this.regexp = regexp;\n    this.groupIndexMapper = groupIndexMapper;\n    this.previousGroupsForGroup = previousGroupsForGroup;\n  }\n\n  execForAllGroups(string, includeFullMatch) {\n    let matches = RegExp.prototype.exec.call(this.regexp, string);\n    if (!matches) return matches;\n    let firstIndex = matches.index;\n    let indexMapper = includeFullMatch ? Object.assign({0: 0}, this.groupIndexMapper) : this.groupIndexMapper;\n    let previousGroups = includeFullMatch ? Object.assign({0: []}, this.previousGroupsForGroup) : this.previousGroupsForGroup;\n\n    return Object.keys(indexMapper).map((group) => {\n      let mapped = indexMapper[group];\n      let r = {\n        match: matches[mapped],\n        start: firstIndex + previousGroups[group].reduce(\n          (sum, i) => sum + (matches[i] ? matches[i].length : 0), 0\n        )\n      };\n      r.end = r.start + (matches[mapped] ? matches[mapped].length : 0);\n\n      return r;\n    });\n  }\n\n  execForGroup(string, group) {\n    const matches = RegExp.prototype.exec.call(this.regexp, string);\n    if (!matches) return matches;\n    const firstIndex = matches.index;\n\n    const mapped = group == 0 ? 0 : this.groupIndexMapper[group];\n    const previousGroups = group == 0 ? [] : this.previousGroupsForGroup[group];\n    let r = {\n      match: matches[mapped],\n      start: firstIndex + previousGroups.reduce(\n        (sum, i) => sum + (matches[i] ? matches[i].length : 0), 0\n      )\n    };\n    r.end = r.start + (matches[mapped] ? matches[mapped].length : 0);\n\n    return r;\n  }\n}\n"]}